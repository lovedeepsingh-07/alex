// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RESPONSE_RESULT: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RESPONSE_RESULT: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_RESULT: [ResponseResult; 3] = [
    ResponseResult::NONE,
    ResponseResult::OK,
    ResponseResult::ERROR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponseResult(pub u8);
#[allow(non_upper_case_globals)]
impl ResponseResult {
    pub const NONE: Self = Self(0);
    pub const OK: Self = Self(1);
    pub const ERROR: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::OK, Self::ERROR];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::OK => Some("OK"),
            Self::ERROR => Some("ERROR"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ResponseResult {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ResponseResult {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ResponseResult {
    type Output = ResponseResult;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResponseResult {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ResponseResult {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ResponseResult {}
pub struct ResponseResultUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_STATUS_SUB_COMMAND: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_STATUS_SUB_COMMAND: i8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATUS_SUB_COMMAND: [StatusSubCommand; 3] = [
    StatusSubCommand::CurrentAudio,
    StatusSubCommand::IsPaused,
    StatusSubCommand::IsQueueEmpty,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StatusSubCommand(pub i8);
#[allow(non_upper_case_globals)]
impl StatusSubCommand {
    pub const CurrentAudio: Self = Self(0);
    pub const IsPaused: Self = Self(1);
    pub const IsQueueEmpty: Self = Self(2);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::CurrentAudio, Self::IsPaused, Self::IsQueueEmpty];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::CurrentAudio => Some("CurrentAudio"),
            Self::IsPaused => Some("IsPaused"),
            Self::IsQueueEmpty => Some("IsQueueEmpty"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for StatusSubCommand {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for StatusSubCommand {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for StatusSubCommand {
    type Output = StatusSubCommand;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StatusSubCommand {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for StatusSubCommand {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for StatusSubCommand {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PLAYER_SUB_COMMAND: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PLAYER_SUB_COMMAND: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAYER_SUB_COMMAND: [PlayerSubCommand; 4] = [
    PlayerSubCommand::Play,
    PlayerSubCommand::Pause,
    PlayerSubCommand::Resume,
    PlayerSubCommand::Clear,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlayerSubCommand(pub i8);
#[allow(non_upper_case_globals)]
impl PlayerSubCommand {
    pub const Play: Self = Self(0);
    pub const Pause: Self = Self(1);
    pub const Resume: Self = Self(2);
    pub const Clear: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Play, Self::Pause, Self::Resume, Self::Clear];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Play => Some("Play"),
            Self::Pause => Some("Pause"),
            Self::Resume => Some("Resume"),
            Self::Clear => Some("Clear"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PlayerSubCommand {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PlayerSubCommand {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for PlayerSubCommand {
    type Output = PlayerSubCommand;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlayerSubCommand {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PlayerSubCommand {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PlayerSubCommand {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COMMAND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COMMAND: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND: [Command; 5] = [
    Command::NONE,
    Command::Status,
    Command::Reload,
    Command::Search,
    Command::Player,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Command(pub u8);
#[allow(non_upper_case_globals)]
impl Command {
    pub const NONE: Self = Self(0);
    pub const Status: Self = Self(1);
    pub const Reload: Self = Self(2);
    pub const Search: Self = Self(3);
    pub const Player: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::Status,
        Self::Reload,
        Self::Search,
        Self::Player,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Status => Some("Status"),
            Self::Reload => Some("Reload"),
            Self::Search => Some("Search"),
            Self::Player => Some("Player"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Command {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Command {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Command {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Command {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Command {}
pub struct CommandUnionTableOffset {}

pub enum OKOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OK<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OK<'a> {
    type Inner = OK<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> OK<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OK { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args OKArgs,
    ) -> flatbuffers::WIPOffset<OK<'bldr>> {
        let mut builder = OKBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for OK<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct OKArgs {}
impl<'a> Default for OKArgs {
    #[inline]
    fn default() -> Self {
        OKArgs {}
    }
}

pub struct OKBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OKBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OKBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        OKBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OK<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OK<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OK");
        ds.finish()
    }
}
pub enum ERROROffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ERROR<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ERROR<'a> {
    type Inner = ERROR<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ERROR<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ERROR { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ERRORArgs<'args>,
    ) -> flatbuffers::WIPOffset<ERROR<'bldr>> {
        let mut builder = ERRORBuilder::new(_fbb);
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ERROR::VT_MESSAGE, None)
        }
    }
}

impl flatbuffers::Verifiable for ERROR<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct ERRORArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ERRORArgs<'a> {
    #[inline]
    fn default() -> Self {
        ERRORArgs { message: None }
    }
}

pub struct ERRORBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ERRORBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ERROR::VT_MESSAGE, message);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ERRORBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ERRORBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ERROR<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ERROR<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ERROR");
        ds.field("message", &self.message());
        ds.finish()
    }
}
pub enum StatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Status<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Status<'a> {
    type Inner = Status<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Status<'a> {
    pub const VT_SUB_COMMAND: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Status { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args StatusArgs<'args>,
    ) -> flatbuffers::WIPOffset<Status<'bldr>> {
        let mut builder = StatusBuilder::new(_fbb);
        if let Some(x) = args.output {
            builder.add_output(x);
        }
        if let Some(x) = args.sub_command {
            builder.add_sub_command(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn sub_command(&self) -> Option<StatusSubCommand> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<StatusSubCommand>(Status::VT_SUB_COMMAND, None)
        }
    }
    #[inline]
    pub fn output(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Status::VT_OUTPUT, None)
        }
    }
}

impl flatbuffers::Verifiable for Status<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<StatusSubCommand>("sub_command", Self::VT_SUB_COMMAND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("output", Self::VT_OUTPUT, false)?
            .finish();
        Ok(())
    }
}
pub struct StatusArgs<'a> {
    pub sub_command: Option<StatusSubCommand>,
    pub output: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StatusArgs<'a> {
    #[inline]
    fn default() -> Self {
        StatusArgs {
            sub_command: None,
            output: None,
        }
    }
}

pub struct StatusBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_sub_command(&mut self, sub_command: StatusSubCommand) {
        self.fbb_
            .push_slot_always::<StatusSubCommand>(Status::VT_SUB_COMMAND, sub_command);
    }
    #[inline]
    pub fn add_output(&mut self, output: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Status::VT_OUTPUT, output);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StatusBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        StatusBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Status<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Status<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Status");
        ds.field("sub_command", &self.sub_command());
        ds.field("output", &self.output());
        ds.finish()
    }
}
pub enum ReloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Reload<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Reload<'a> {
    type Inner = Reload<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Reload<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Reload { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args ReloadArgs,
    ) -> flatbuffers::WIPOffset<Reload<'bldr>> {
        let mut builder = ReloadBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for Reload<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ReloadArgs {}
impl<'a> Default for ReloadArgs {
    #[inline]
    fn default() -> Self {
        ReloadArgs {}
    }
}

pub struct ReloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReloadBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReloadBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReloadBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Reload<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Reload<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Reload");
        ds.finish()
    }
}
pub enum SearchOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Search<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Search<'a> {
    type Inner = Search<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Search<'a> {
    pub const VT_SEARCH_RESULT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Search { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SearchArgs<'args>,
    ) -> flatbuffers::WIPOffset<Search<'bldr>> {
        let mut builder = SearchBuilder::new(_fbb);
        if let Some(x) = args.search_result {
            builder.add_search_result(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn search_result(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(Search::VT_SEARCH_RESULT, None)
        }
    }
}

impl flatbuffers::Verifiable for Search<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("search_result", Self::VT_SEARCH_RESULT, false)?
            .finish();
        Ok(())
    }
}
pub struct SearchArgs<'a> {
    pub search_result: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for SearchArgs<'a> {
    #[inline]
    fn default() -> Self {
        SearchArgs {
            search_result: None,
        }
    }
}

pub struct SearchBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SearchBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_search_result(
        &mut self,
        search_result: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Search::VT_SEARCH_RESULT, search_result);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SearchBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SearchBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Search<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Search<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Search");
        ds.field("search_result", &self.search_result());
        ds.finish()
    }
}
pub enum PlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Player<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Player<'a> {
    type Inner = Player<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Player<'a> {
    pub const VT_SUB_COMMAND: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Player { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PlayerArgs,
    ) -> flatbuffers::WIPOffset<Player<'bldr>> {
        let mut builder = PlayerBuilder::new(_fbb);
        builder.add_sub_command(args.sub_command);
        builder.finish()
    }

    #[inline]
    pub fn sub_command(&self) -> PlayerSubCommand {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PlayerSubCommand>(Player::VT_SUB_COMMAND, Some(PlayerSubCommand::Play))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Player<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<PlayerSubCommand>("sub_command", Self::VT_SUB_COMMAND, false)?
            .finish();
        Ok(())
    }
}
pub struct PlayerArgs {
    pub sub_command: PlayerSubCommand,
}
impl<'a> Default for PlayerArgs {
    #[inline]
    fn default() -> Self {
        PlayerArgs {
            sub_command: PlayerSubCommand::Play,
        }
    }
}

pub struct PlayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlayerBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_sub_command(&mut self, sub_command: PlayerSubCommand) {
        self.fbb_.push_slot::<PlayerSubCommand>(
            Player::VT_SUB_COMMAND,
            sub_command,
            PlayerSubCommand::Play,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlayerBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PlayerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Player<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Player<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Player");
        ds.field("sub_command", &self.sub_command());
        ds.finish()
    }
}
pub enum ResponsePacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResponsePacket<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResponsePacket<'a> {
    type Inner = ResponsePacket<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ResponsePacket<'a> {
    pub const VT_RESULT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_RESULT: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ResponsePacket { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ResponsePacketArgs,
    ) -> flatbuffers::WIPOffset<ResponsePacket<'bldr>> {
        let mut builder = ResponsePacketBuilder::new(_fbb);
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        if let Some(x) = args.result {
            builder.add_result(x);
        }
        builder.add_command_type(args.command_type);
        builder.add_result_type(args.result_type);
        builder.finish()
    }

    #[inline]
    pub fn result_type(&self) -> ResponseResult {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ResponseResult>(ResponsePacket::VT_RESULT_TYPE, Some(ResponseResult::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn result(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ResponsePacket::VT_RESULT,
                    None,
                )
        }
    }
    #[inline]
    pub fn command_type(&self) -> Command {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Command>(ResponsePacket::VT_COMMAND_TYPE, Some(Command::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn command(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ResponsePacket::VT_COMMAND,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn result_as_ok(&self) -> Option<OK<'a>> {
        if self.result_type() == ResponseResult::OK {
            self.result().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { OK::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn result_as_error(&self) -> Option<ERROR<'a>> {
        if self.result_type() == ResponseResult::ERROR {
            self.result().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ERROR::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_status(&self) -> Option<Status<'a>> {
        if self.command_type() == Command::Status {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Status::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_reload(&self) -> Option<Reload<'a>> {
        if self.command_type() == Command::Reload {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Reload::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_search(&self) -> Option<Search<'a>> {
        if self.command_type() == Command::Search {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Search::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn command_as_player(&self) -> Option<Player<'a>> {
        if self.command_type() == Command::Player {
            self.command().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Player::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ResponsePacket<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<ResponseResult, _>(
                "result_type",
                Self::VT_RESULT_TYPE,
                "result",
                Self::VT_RESULT,
                false,
                |key, v, pos| match key {
                    ResponseResult::OK => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<OK>>(
                            "ResponseResult::OK",
                            pos,
                        ),
                    ResponseResult::ERROR => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ERROR>>(
                            "ResponseResult::ERROR",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_union::<Command, _>(
                "command_type",
                Self::VT_COMMAND_TYPE,
                "command",
                Self::VT_COMMAND,
                false,
                |key, v, pos| match key {
                    Command::Status => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Status>>(
                            "Command::Status",
                            pos,
                        ),
                    Command::Reload => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Reload>>(
                            "Command::Reload",
                            pos,
                        ),
                    Command::Search => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Search>>(
                            "Command::Search",
                            pos,
                        ),
                    Command::Player => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Player>>(
                            "Command::Player",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ResponsePacketArgs {
    pub result_type: ResponseResult,
    pub result: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ResponsePacketArgs {
    #[inline]
    fn default() -> Self {
        ResponsePacketArgs {
            result_type: ResponseResult::NONE,
            result: None,
            command_type: Command::NONE,
            command: None,
        }
    }
}

pub struct ResponsePacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ResponsePacketBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_result_type(&mut self, result_type: ResponseResult) {
        self.fbb_.push_slot::<ResponseResult>(
            ResponsePacket::VT_RESULT_TYPE,
            result_type,
            ResponseResult::NONE,
        );
    }
    #[inline]
    pub fn add_result(&mut self, result: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ResponsePacket::VT_RESULT, result);
    }
    #[inline]
    pub fn add_command_type(&mut self, command_type: Command) {
        self.fbb_.push_slot::<Command>(
            ResponsePacket::VT_COMMAND_TYPE,
            command_type,
            Command::NONE,
        );
    }
    #[inline]
    pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ResponsePacket::VT_COMMAND, command);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ResponsePacketBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ResponsePacketBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ResponsePacket<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ResponsePacket<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ResponsePacket");
        ds.field("result_type", &self.result_type());
        match self.result_type() {
            ResponseResult::OK => {
                if let Some(x) = self.result_as_ok() {
                    ds.field("result", &x)
                } else {
                    ds.field(
                        "result",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ResponseResult::ERROR => {
                if let Some(x) = self.result_as_error() {
                    ds.field("result", &x)
                } else {
                    ds.field(
                        "result",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("result", &x)
            }
        };
        ds.field("command_type", &self.command_type());
        match self.command_type() {
            Command::Status => {
                if let Some(x) = self.command_as_status() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Command::Reload => {
                if let Some(x) = self.command_as_reload() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Command::Search => {
                if let Some(x) = self.command_as_search() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Command::Player => {
                if let Some(x) = self.command_as_player() {
                    ds.field("command", &x)
                } else {
                    ds.field(
                        "command",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("command", &x)
            }
        };
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ResponsePacket`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn root_as_response_packet(
    buf: &[u8],
) -> Result<ResponsePacket, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<ResponsePacket>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ResponsePacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_response_packet_unchecked`.
pub fn size_prefixed_root_as_response_packet(
    buf: &[u8],
) -> Result<ResponsePacket, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<ResponsePacket>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ResponsePacket` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn root_as_response_packet_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<ResponsePacket<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<ResponsePacket<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ResponsePacket` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_packet_unchecked`.
pub fn size_prefixed_root_as_response_packet_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<ResponsePacket<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<ResponsePacket<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ResponsePacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ResponsePacket`.
pub unsafe fn root_as_response_packet_unchecked(buf: &[u8]) -> ResponsePacket {
    flatbuffers::root_unchecked::<ResponsePacket>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ResponsePacket and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ResponsePacket`.
pub unsafe fn size_prefixed_root_as_response_packet_unchecked(buf: &[u8]) -> ResponsePacket {
    flatbuffers::size_prefixed_root_unchecked::<ResponsePacket>(buf)
}
#[inline]
pub fn finish_response_packet_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ResponsePacket<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_response_packet_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ResponsePacket<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
